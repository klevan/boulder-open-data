---
layout: post
title: "The Affordability of Open Space"
excerpt: "Can you buy a house with decent access to the Flatirons?"
tags: [market, Zillow, real estate, housing]
comments: true
image:
  feature: flatirons.jpg
  credit: Zach Ancell
  creditlink: https://www.flickr.com/photos/zachancell/3682237473
---
# Boulder & Open Space Access
I work in the Boulder, Colorado area. It is a beautiful locale and the community as a whole really values its open space. The fact that my co-workers joke about the cost-of-living penalty of living close the flatiron mountains highlights just how desirable access to the outdoors is for this area. Because Boulder participates in the [Open Data movement](https://bouldercolorado.gov/open-data), I decided to look into this phenomenon a little more closely. 
```{r libraries functions & paths}
rm(list = ls())

# Function
options(stringsAsFactors = FALSE) 
multipleCombine <- function(input, ply = llply){
  require(plyr)
  require(dplyr)
  ply(input, function(x){
    t <- read.table(x, header=TRUE, sep=",",stringsAsFactors = FALSE)
    t1 <- rbind(t) 
    return(t1)
  }
  )
}

# Libraries
library(Zillow)
library(plyr)
library(dplyr)
library(maps)
library(mapproj)
library(foreign)
library(maptools)
library(ggmap)
library(raster)
library(sp)

# Paths
setwd("~/GitHub/boulder-open-data")
pathToData <- paste(getwd(),"data",sep="/")
```

# Getting the data
Data for this post come from two sources: the [Boulder Open Data Catalog](https://bouldercolorado.gov/open-data/boulder-addresses/) and the [Zillow API](http://www.zillow.com/howto/api/GetZestimate.htm). From the Boulder Catalog, I downloaded the .dbf and .shp files associated with all Boulder addresses. From Zillow, I used the Zillow API library in R, which makes it simple to use the API programatically; see `r install.package("Zillow")`. To use the API, you will need a zillow ID. Zillow uses this identifier to limit the number of calls you make to their servers. Boulder has ~50,000 addresses. To get price data associated with these addresses, I had to use a try block and do the procedure repeatedly. Zillow does have a mechanism to increase the number of queries you can make each day, but I was told that they don't lift that cap for data viz projects. 
```{r setting up for data,echo=TRUE}
# To get Zillow data you need a zillow ID
zillowId <- read.table(paste(getwd(),"ZWSID.txt",sep="/"), encoding="UTF8",
                       row.names=NULL, quote="", comment.char="", stringsAsFactors=FALSE)[1,]

# Boulder addresses
boulderList <- read.dbf(paste(getwd(),"Boulder_addresses","Boulder_addresses.dbf",sep="/"))

boulder.map <- readShapePoints(paste(getwd(),"Boulder_addresses","Boulder_addresses.shp",sep="/"))
crs(boulder.map) <- "+proj=utm +units=m +ellps=WGS84"
```

# Harvesting price data
I've set up some try blocks that will periodically try to harvest housing market data on addresses for which I don't have information yet. In my experience, Zillow will let me do about 2500 calls to their API before they shut me down for a while.
```{r try block to harvest price data}
# Do I already have some of this data?
addressIDs <- sort(unique(boulderList$ADDRESSID))

# Locations that I already have data from
fileList <- list.files(pathToData, full.names=TRUE)
boulder.dbf <- multipleCombine(fileList, ply = ldply)
boulder.dbf %>% filter(is.na(price)==FALSE)-> boulder.dbf

# Remove locations I don't need to check
addressIDs <- addressIDs[addressIDs%in%boulder.dbf$ADDRESSID==FALSE]
boulderList$price <- NA

runscript <- FALSE # Don't run this until I specify
if(runscript==TRUE){
t <- addressIDs[1]
for (j in addressIDs[1:2500]){ 
  tmp <- try(boulderList$price[boulderList$ADDRESSID==j] <- as.numeric(zestimate(boulderList$ADDRESS[j],
                                                                                 boulderList$ZIPCODE[j],zillowId)$amount))
  if (class(tmp)=="try-error"){
    boulderList$price[boulderList$ADDRESSID==j] <- NA
    j <- addressIDs[match(j,addressIDs)+1]
  }
  if(match(j, addressIDs)%%1000==0){
    write.csv(boulderList[addressIDs[t:j],],file = paste(paste(pathToData,j,sep='/'),'csv',sep="."),
              row.names = FALSE)
    t <- addressIDs[match(j,addressIDs)+1]
  }
}
all <- boulderList[is.na(boulderList$price)==FALSE,]
write.csv(all,file = paste(paste(pathToData,all$ADDRESSID[dim(all)[1]],sep='/'),'csv',sep="."),
              row.names = FALSE)
}
```

# Looking at pricing data
Certain neighborhoods are pricier than others. The warmer the heat colors, the more expensive the area.
```{r visualizing the data, echo=TRUE}
# Collate all the data files
fileList <- list.files(pathToData, full.names=TRUE)
boulder.dbf <- multipleCombine(fileList, ply = ldply)
boulder.dbf %>% filter(is.na(price)==FALSE)-> boulder.dbf
boulder.dbf <- unique.data.frame(boulder.dbf[order(boulder.dbf$price),])

# Bounding box
bbox <- c(min(boulderList$LONGITUDE),min(boulderList$LATITUDE),
          max(boulderList$LONGITUDE),max(boulderList$LATITUDE))
boulder.map <- get_map(location = bbox,maptype="terrain")

# Plotting the data
mini <- min(boulder.dbf$price)
maxi <- max(boulder.dbf$price)
step <- (maxi-mini)/5
t=5

plot(boulder.dbf$LONGITUDE,boulder.dbf$LATITUDE,
     xlab="Longitude",ylab="Latitude",col="white")


for (i in seq(mini,maxi,step)){
  boulder.dbf %>% 
    filter(price<i, (i-step)<price) -> b
  points(b$LONGITUDE,b$LATITUDE,
         xlab="Longitude",ylab="Latitude",bg=heat.colors(5)[t],pch=21,
         cex=2)
  t=t-1
}
```

